
软件在bdftocode里面，使用前先检查MD5，确保没有被篡改植入病毒木马等。

U8glib字体转换软件.exe
61449BDA7B77031B9C25577CCA4B4BE0


bdf2u8g.exe
8BEA98F6B7F096BDD16B7D635FD80D8D


MD5软件可以在“银河证券”官网下载 http://www.chinastock.com.cn/yhwz/service/download.shtml
网页中间“相关下载”标题栏，右边有一个“MD5使用说明及下载”的按钮，按下确认即可下载。



有些垃圾杀毒软件会了拦截 bdf2u8g.exe，不让调用，导致运行出错。
比如COMODO互联网套装就是这样，无声无息地禁止调用，关闭杀毒之后就能使用。




fonts 文件夹收集了一些字体



FontTool 文件夹里面是 TTF字体文件转bdf字体文件的工具



运行软件之后：

输入要转换的字，不要间隔空格，因为空格也被当成字，如“东南西北”。

有些字库里面没有英文字，没有符号的，转换也可能出错。

然后选择一个字体文件，如 “..\fonts\unifont.bdf”

然后定义一个字体名称，如“dnxb”，要什么填什么

按开始会生成这样的代码

/*
  Fontname: -Firefly-Firefly New Sung-Medium-R-Normal--11-110-75-75-P-109-ISO10646-1
  Copyright: 
  Capital A Height: 0, '1' Height: 0
  Calculated Max Values w= 9 h=10 x= 1 y= 0 dx=11 dy= 0 ascent= 9 len= 0
  Font Bounding box     w=11 h=11 x= 0 y=-1
  Calculated Min Values           x= 0 y=-1 dx= 0 dy= 0
  Pure Font   ascent = 0 descent= 0
  X Font      ascent = 0 descent= 0
  Max Font    ascent = 9 descent=-1
*/
#include "utility\u8g.h"
const u8g_fntpgm_uint8_t dnxb[] U8G_FONT_SECTION("dnxb") = {
0,11,11,0,255,0,0,0,0,0,0,3,0,9,255,0,
//东 (\x00)
0,9,10,21,11,1,255,17,0,255,128,32,0,72,0,255,
0,8,0,42,0,73,0,152,128,8,0,
//南 (\x01)
0,9,10,21,11,1,255,8,0,255,128,8,0,255,128,148,
128,255,128,136,128,190,128,136,128,139,128,
//西 (\x02)
0,9,10,21,11,1,255,255,128,20,0,255,128,148,128,148,
128,148,128,163,128,128,128,255,128,128,128,
//北 (\x03)
0,10,10,20,11,1,255,18,0,18,0,18,0,243,128,18,
0,18,0,18,0,50,0,210,64,19,192};

/*
Sample(调用例子):
  u8g.firstPage();
  do
  {
  u8g.setFont(dnxb);
  //u8g.drawStr( 0, 9, "\x00\x01\x02\x03");
  u8g.setPrintPos(0, 9);
  u8g.print("\x00\x01\x02\x03");
  } while (u8g.nextPage());
*/



有些字体无法正确显示，比如“一”字，检查过字体文件没错，转换出来的代码也没错，
就是不能正常显示，没研究清楚是什么原因。


可以使用多组字体


#include "utility\u8g.h"                                       
const u8g_fntpgm_uint8_t dnxb[] U8G_FONT_SECTION("dnxb") = { //第一组字体
0,11,11,0,255,0,0,0,0,0,0,3,0,9,255,0,
//东(\x00)
0,9,10,21,11,1,255,17,0,255,128,32,0,72,0,255,
0,8,0,42,0,73,0,152,128,8,0,
//南(\x01)
0,9,10,21,11,1,255,8,0,255,128,8,0,255,128,148,
128,255,128,136,128,190,128,136,128,139,128,
//西(\x02)
0,9,10,21,11,1,255,255,128,20,0,255,128,148,128,148,
128,148,128,163,128,128,128,255,128,128,128,
//北(\x03)
0,10,10,20,11,1,255,18,0,18,0,18,0,243,128,18,
0,18,0,18,0,50,0,210,64,19,192};


const u8g_fntpgm_uint8_t sxzy[] U8G_FONT_SECTION("sxzy") = { //第二组字体，字体名不同
0,11,11,0,255,0,0,0,0,0,0,3,0,9,255,0,
//上(\x00)
0,10,10,21,11,0,255,8,0,8,0,8,0,15,128,8,
0,8,0,8,0,8,0,8,0,255,192,
//下(\x01)
0,9,10,21,11,1,255,255,128,8,0,8,0,12,0,11,
0,9,0,8,0,8,0,8,0,8,0,
//左(\x02)
0,10,10,21,11,0,255,8,0,255,192,8,0,8,0,16,
0,47,128,66,0,130,0,2,0,63,192,
//右(\x03)
0,10,10,20,11,0,255,8,0,8,0,255,192,8,0,16,
0,63,128,80,128,144,128,31,128,16,128};




  u8g.setFont(dnxb);//显示第一组的字体
  u8g.setPrintPos(0, 14);
  u8g.print("\x03"); //显示北字

  u8g.setFont(sxzy);//显示第二组的字体
  u8g.setPrintPos(0, 14);
  u8g.print("\x00"); //显示上字




这个程序生成的字体，绝对不会缺笔少点，当然也不会多一个点，是完美的，

至于有网友说什么从第二个字开始删除前面的0会更完美，根本没那回事，

至于网上说从第二个字开始删掉最后一个字节，也是错的，那是有效的点阵数据，不能删除的，















